# Декомпозиция сервисов

## Шаги к успеху
1. Описать сценарии использования
2. Определить системные действия с
   приложением
3. Построить доменную модель (модели)
4. Построить сервисную модель
5. Протестировать сервисную модель
6. Повторить п3 – п5 пока не станет хорошо

## Описание сценариев
Удобная аннотация Gherkin (Given when then). И концепция [BDD](https://ru.wikipedia.org/wiki/BDD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

## Модель предметной области
**Системные действия** – это действия, которые совершает пользователь и приложение в рамках пользовательского сценария.
**Модель предметной области** – это набор инвариантов и ограничений предметной области, описанных в том или ином виде.

### Определение сущностей
Взять язер стори и выделить в них существительные.
- **Клиент** ищет **продукт** по выбранным параметрам
- **Клиент** получает данные о **продукте**
- **Клиент** кладет **продукт** в **корзину**

Далее:
- По этим сущностям строится модель - подойдет UML диаграмма классов
- Добавляем добавляем в UML методы
- Добавить другие системные функции - например интеграции с платежками и проч.  

Начиная с этого момента уже можно:
В целом мы можем добавлять сущностей или делать модель более детализированной.  
Чтобы перейти к моделированию сервисов, для сложных предметных областей, мы должны каким-то образом провести границы, по которым сервисы будут проходить.  
В DDD есть соответствующие паттерны для проведения таких границ – модули, агрегаты и сервисы.  

## Event storming
Функциональный и ООП подход хорошо подходит для небольших проектов. Для больших стоит прибегнуть к Event Storming-у.
- Представляем бизнес процесс в виде набора действий, запросов, событий, акторов, агрегатов и внешних систем.
- Пытаемся провести границы вокруг сущностей, которые потом станут границами команд и микросервисов (или группы микросервисов).
- В ограниченны контекст включается: описание, бизнес правила, запроса + команды + события, зависимости от других контекстов

**Event storming** – это собрание, на котором разработчики и бизнес вместе выясняют, как же выглядит предметная область.

### Event storming. Проблемы и особенности
- Очень многословен. Фактически для создания подробного event storming-а требуется написать спецификацию всего кода в терминах DDD. Даже для небольших проектов он может быть многословен. [https://github.com/ddd-by-examples/library](https://github.com/ddd-by-examples/library)
- Может содержать ошибки. Кто-то какие-то события не вспомнил, ктото что-то неправильно написал и т.д. В целом это больше инструмент коммуникации, нежели подробного и точного моделирования.
- Результаты моделирования остаются на бумаге (точнее на стене) и ими дальше не руководствуются в принятии архитектурных решений.
- В рамках Event Storming лучше моделировать большие bounded context-ы (в среднем 1 на 1 команду).
- Моделирование маленьких ограниченных контекстов и деление на сервисы/микросервисы в рамках сессии event storming кажется не продуктивным.

## Моделирование:
Какой бы способ мы ни выбрали, в любом случае надо понимать, что из модели мы получаем лишь первое приближение для разбиения сервисов.  
И в дальнейшем разделение на сервисы мы можем делать исходя из нефункциональных требований – требований производительности, безопасности, масштабируемости и т.д и т.п.

**Как моделировать**:  
Прописываем системные действия для каждого сервиса уже в виде API
- Пробегаемся по основным сценариям и смотрим, не забыли ли мы чтонибудь и насколько хорошее и полное API у нас получается.
- Проходим по всем сервисам и определяем ответственность сервиса, зависимости между сервисами, пытаемся прописать конкретное API и  выбираем протокол для взаимодействия
- Находим проблемы в текущей модели разбиения
- Корректируем модель и разбиение.
- Повторяем

##Описание сервисов
Для более формального описания сервисов может подойти один из шаблонов для описания:
- [MicroservicesCanvas](https://launchany.com/microservice-design-canvas/)
- [BoundedContextCanvas](https://habr.com/ru/company/oleg-bunin/blog/500506/)  

Крч. нормально будет выглядеть если заполнить вот так:
- **Название:**  
  Продукт
- **Запросы:**  
  Поиск продукта GET /api/v1/search/?q=…   
  Информация о продукте  GET /api/v1/products/{id}
- **Команды:**  
  Изменение товарной номенклатуры POST on /api/v1/products/{id}
- **События:**  
  \-  
- **Зависимости:**  
  Слушает события ProductReserveChanged от Склада.
- **Вопросы:**  
  Атрибуты для поиска продуктов и технология – Elastic Search/Solr для поиска использовать?

## Рекомендации
- Начинайте с основного пользовательского сценария
- Исходя из пользовательского сценария с помощью одного из методов
   постройте модель предметной области
- Из модели предметной области сделайте нулевую итерацию разбиения
   сервисов
- Пройдитесь по всем сценариям и для каждого сервиса попробуйте
   конкретно описать его взаимодействие с клиентом, и с другими
   сервисами. Например, используя MicroserviceCanvas
- Оцените сервисную модель: какие у нее есть слабые стороны,
   проблемы, какие возникли вопросы в рамках составления карточки
   сервисов? Как с точки зрения функциональных, так и не функциональных
   требований.
- Придумайте решение проблем текущего разбиения, и переразбейте
   сервисы, по-другому организуйте взаимодействие (и т.д)
- Повторяйте п 4-6 до полного просветления
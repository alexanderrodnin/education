# Репликация PG

**Репликация** – процесс синхронизации нескольких копий одного объекта.  
Несколько кластеров PostgreSQL на разных серверах.  
Решает задачу отказоустройчивости и масштабируемости.


## Задачи репликации
- Балансирование нагрузки
- Резервирование – это не бекап! А вот бекап можно делать с реплики.
- Обновление
- Горизонтальное масштабирование
- Геораспределение нагрузки

##Виды репликации
- Физическая репликация - описание изменений на уровне файлов.
Побайтовая копия данных.
- Логическая репликация - изменения данных в терминах строк таблиц.
Более высокий уровень, чем файлы данных.
  
## Физическая репликация
**WAL** (Write Ahead Log) – файл предзаписи и название механизма записи данных в
журнал, перед запись в датафайл. Так же определение самого процесса ведения
журнала предзаписи.
- Записи WAL передаются на реплику и применяются
    - поток данных только в одну сторону – от основного (ведущего севера)
    - реплицируется кластер целиком, выборочная реплика невозможна
- Реплика — точная копия основного сервера
    - одна и та же основная (мажорная) версия сервера
    - полностью совместимые архитектуры и платформы
- Реплика доступна только для чтения и для создания так называемой каскадной репликации.

#### Плюсы и минусы физической репликации
**Плюсы**
- Подключается по протоколу репликации
- ARIES* - они же WAL логи
- Есть из коробки

**Минусы**
- Кластер реплицируется целиком
- Реплицируются физические ошибки
- Только в рамках одной мажорной Версии
- Большие накладные расходы

### Сценарии использования физической репликации
- Горячий резерв для высокой доступности
- Балансировка OLTP-нагрузки (high load)
- Реплика для отчетов
- Несколько реплик и каскадная репликация
- Отложенная репликация

### Возможности реплики
**Можно**:
- запросы на чтение данных (select, copy to, курсоры)
- установка параметров сервера (set, reset)
- управление транзакциями (begin, commit, rollback...)
- создание резервной копии (pg_basebackup)    

**Нельзя**:
- любые изменения (insert, update, delete, truncate, nextval...) блокировки, предполагающие изменение (select for update...)
- команды DDL (create, drop...), в том числе создание временных таблиц
- команды сопровождения (vacuum, analyze, reindex...)
- управление доступом (grant, revoke...)

### Слоты репликации
Мастер может удалить файл журнала, нужный реплике, если реплика не успеет его получить (например, будет остановлена на некоторое время).  
**Слот репликации** - вводит зависимость матера от реплики, требует мониторинга. Архив журнала предзаписи позволяет обойтись без слота.
```sql
SELECT pg_create_physical_replication_slot(‘otus’); 
```  
### Асинхронная репликация
Последовательное выполнение транзакций на всех репликах. Хорошая пропускная способность.
Таким образом появляется время отклика в течении которого отдельные реплики могут быть фактически неидентичными.
```sql
synchronous_commit = off
```

### Синхронная репликация
Коммит на реплике должен быть доступен до того, как он будет доступен
на мастере
**Плюсы** - Один большой плюс в том, что в момент отказа мы получаем абсолютно идентичные мастер и реплику. Конечно, могут потеряться последние транзакции которые еще не были зафиксированы, но мастер и реплика в любом случае идентичны.
**Минусы** - Проблемы с производительностью. Primary ждет ответа от реплики о удачном коммите.  
В случаях возникновения проблем с репликой Primary останавливается и не может работать дальше до тех пор пока Реплика не будет
восстановлена либо до тех пор пока вы не удалите такую реплику из списка синхронных реплика на Primary сервере.
```sql
synchronous_standby_names = (список реплик)
synchronous_commit = off (on, local, remote_write, remote_apply)
```
**on** - подтверждает, что произошла запись на диск в WAL файл
**local** – дожидаемся только того, что запись будет сброшена на локальный диск
**remote_write** - дожидаемся только ответа о том, что информация дошла до реплики, но не факт, что произошла запись на диск
**remote_apply** - дает подтверждение тому, что запись применена в базе

### Куда смотреть
**На Мастере**:
Процесс можно отслеживать в представлении pg_current_wal_lsn(), остальные — представление pg_stat_replication. Реплика передает мастеру статус
репликации при каждой записи на диск, но как минимум раз в wal_receiver_status_interval секунд (по умолчанию — 10 секунд).
Если используется слот репликации, то информацию о нем можно получить из представления pg_replication_slots.  

**На Реплике**:
В представлении pg_stat_wal_receiver и с помощью функций pg_last_wal_receive_lsn() и pg_last_wal_replay_lsn().

### Наиболее используемые параметры
```sql
max_wal_senders – по дефолту 10. Выставляем по кол-ву реплик и архиваторов.
max_worker_processes - должно быть таким же или большим, чем на Мастер
сервере. Иначе нельзя будет делать запросы на Реплику.
wal_level - replica или logical (replica default)
archive_mode - on|off|always
full_page_writes - отключение не влияет на возможность применения архивов
WAL для восстановления
commit_delay - по умолчанию 0
wal_keep_segments- достаточное чтобы хватило реплике
max_replication_slots- в зависимости от необходимости в кол-ве слотов
```
```sql
CREATE USER replicator WITH REPLICATION Encrypted PASSWORD ‘super_password’;
pg_basebackup –h 192.168.1.10 –U replicator –p 5432 –D $PGDATA –Fp –Xs –P – R
Fp - Format plain. Копирует простые файлы. Если есть tablespaces, то кладет их по их
абсолютным путям
Xs – Method stream. Копирует WAL сегменты используя потоковый протокол
P – Progress reporting
R – Create standby.signal
```

## Повышение реплики до мастера
**Причины**
- плановое переключение (switchover):
- останов основного сервера для проведения технических работ
- аварийное переключение (failover):
- переход на реплику из-за сбоя основного сервера
**Процедура**
- убедиться, что мастер остановлен
- переключение вручную: «продвижение» или триггерный файл
- автоматическое переключение отсутствует

## Возвращение Мастера в строй
**Варианты**
- Непосредственное подключение – возможно только если реплика получила (может получить) все журналы
- Новая реплика с нуля – может занять много времени, но иногда другого варианта нет
- pg_rewind – откатывает потерянные WAL записи по сути копирую их с целевого сервера

## Логическая репликация
- Тоже основана на WAL
- Не передает DDL
- Нельзя изменять объекты (схемы, названия)
- Встроенная фича с 10 версии

### Сценарии использования логической репликации
- Консолидация и общие справочники
- Обновление основной версии сервера.
- Мастер-Мастер (в будущем)

### Отличия от физической репликации
- Нет понятия Мастер, Реплика
- На сервере создается публикация, на которую другие серверы могут подписываться
- Подписчику передается информация об изменениях строк в таблицах: двоичная совместимость не требуется.

### Ограничения логической репликации
Реплицируются не все изменения
- только команды INSERT, UPDATE, DELETE
- только базовые таблицы
- не реплицируются последовательности, материализованные представления, секционированные таблицы.  

Подписку можно создать только на основном сервере
- не работает на физических репликах

## Мастер-мастер репликация
Любой сервер – полная копия доступная для записи
- Высокая вероятность конфликтов
- Сложность в администрировании
- Сложность восстановления
- Bucardo & BDR
- Postgres XC XL (2nd Quadrant)
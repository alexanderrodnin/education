### Let, Const, Var
Операторы декларации переменных и констант.  
Область видимости let и const - фактические аналогична поведению в var и const в Java.  
Поведение var - аналогично поведению var в классическом JS, область ее видимости распространяется на весь блок.  
**Best practice**: использовать let и const. Про var забыть.

### Операторы Spread и Rest (...)
Фактически данные операторы либо разбивают, либо собирают массив.  
Примеры:
```ecmascript 6
function foo(x,y,z) {
console.log( x, y, z );
}
foo( ...[1,2,3] ); // 1 2 3
```
```ecmascript 6
var a = [2,3,4];
var b = [ 1, ...a, 5 ];
console.log( b ); // [1,2,3,4,5]
```
```ecmascript 6
function foo(x, y, ...z) {
console.log( x, y, z );
}
foo( 1, 2, 3, 4, 5 ); // 1 2 [3,4,5]
```
```ecmascript 6
function foo(...args) {
console.log( args );
}
foo( 1, 2, 3, 4, 5); // [1,2,3,4,5]
```
Также есть способ использовать запись вида:
```ecmascript 6
function foo(...args) {
}
```
Как аналог доступа к устаревшему классическому arguments.

### Использование значений по умолчанию
```ecmascript 6
function foo(x = 11, y = 31) { console.log( x + y ); }

foo(); // 42
foo( 5, 6 ); // 11
foo( 0, 42 ); // 42
foo( 5 ); // 36
foo( 5, undefined ); // 36 <-- 'undefined' отсутствует
foo( 5, null ); // 5 <-- null приводится к '0'
foo( undefined, 6 ); // 17 <-- 'undefined' отсутствует
foo( null, 6 ); // 6 <-- null приводится к '0'
```
Также можно использовать функцию как значение по умолчанию
```ecmascript 6
function bar(val) {
    console.log( "bar called!" );
    return y + val;
}
function foo(x = y + 3, z = bar( x )) {
    console.log( x, z );
}
var y = 5;
foo();        // "bar called"
              // 8 13
foo( 10 );    // "bar called"
              // 10 15
y = 6;
foo( undefined, 10 ); // 9 10
```

### Деструктивное присваивание
Суть в том что искомый объект или массив раскладывается на составляющие элементы и присваивается новой структуре.
```ecmascript 6
function foo() {
    return [1,2,3];
}

function bar() {
    return {
        x: 4,
        y: 5,
        z: 6
    };
}

var [ a, b, c ] = foo();
var { x: x, y: y, z: z } = bar();

console.log( a, b, c ); // 1 2 3
console.log( x, y, z ); // 4 5 6
```
**Важно**: Если деструктурирующее присваивание объекта происходит не внутри оператора var/let/const, все выражение присваивания 
следует поместить в круглые скобки ( ), потому что в противном случае находящееся слева содержимое фигурных скобок { .. } будет рассматриваться как блок, а не как объект.
```ecmascript 6
var o = {};
[o.a, o.b, o.c] = foo();
( { x: o.x, y: o.y, z: o.z } = bar() );
console.log( o.a, o.b, o.c ); // 1 2 3
console.log( o.x, o.y, o.z ); // 4 5 6
```
**А также:** подобные присвоения поддерживают:
- повторные присваивания 
- выражения деструктурирующего присваивания
- частичные присвоения
- присваивание значений по умолчанию
- вложенное деструктурирующее присваивание
- деструктуризация параметров
- значения по умолчанию для деструктуризации и для параметров 
- вложенные значения по умолчанию: деструктурированные и реструктурированные

### Расширения объектных литералов.


